/* DO NOT EDIT THIS FILE */

#include <math.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <time.h>

#include "color.h"
#include "image.h"
#include "log.h"
#include "opencl.h"
#include "sinoscope.h"
#include "viewer.h"

typedef struct timespec timespec_t;
typedef struct timeval timeval_t;
typedef struct rusage rusage_t;

static const unsigned int BYTE_PER_PIXEL = 3;

sinoscope_t* sinoscope_create(char* name, sinoscope_handler handler, unsigned int width, unsigned int height,
                              float max) {
    sinoscope_t* sinoscope = malloc(sizeof(*sinoscope));
    if (sinoscope == NULL) {
        LOG_ERROR_ERRNO("malloc");
        goto fail_exit;
    }

    sinoscope->name    = name;
    sinoscope->handler = handler;

    sinoscope->buffer_size = width * height * BYTE_PER_PIXEL;
    sinoscope->buffer      = malloc(sinoscope->buffer_size);
    if (sinoscope->buffer == NULL) {
        LOG_ERROR_ERRNO("malloc");
        goto fail_free_sinoscope;
    }

    sinoscope->width  = width;
    sinoscope->height = height;
    sinoscope->taylor = 3;

    sinoscope->interval         = color_get_interval(max);
    sinoscope->interval_inverse = color_get_interval_inverse(max);

    sinoscope->time   = 0;
    sinoscope->max    = max;
    sinoscope->phase0 = 0;
    sinoscope->phase1 = 0;
    sinoscope->dx     = 3 * M_PI / width;
    sinoscope->dy     = 3 * M_PI / height;
    sinoscope->opencl = NULL;

    return sinoscope;

fail_free_sinoscope:
    free(sinoscope);
fail_exit:
    return NULL;
}

void sinoscope_destroy(sinoscope_t* sinoscope) {
    free(sinoscope->buffer);
    free(sinoscope);
}

int sinoscope_corners(sinoscope_t* sinoscope) {
    if (sinoscope == NULL) {
        LOG_ERROR_NULL_PTR();
        goto fail_exit;
    }

    if (sinoscope->width == 0) {
        LOG_ERROR("invalid width received");
        goto fail_exit;
    }

    if (sinoscope->height == 0) {
        LOG_ERROR("invalid height received");
        goto fail_exit;
    }

    float time = sinoscope->time;
    float fact = (sinoscope->width * sinoscope->height) * 0.5;
    float max  = 1000000.0;

    sinoscope->phase0 = ((max / 2) * sinf(time * 0.1) + (max / 2)) / fact;
    sinoscope->phase1 = ((max / 2) * sinf(time * 0.2) + (max / 2)) / fact;
    sinoscope->time += 0.01;

    if (sinoscope->time > 2 * M_PI * 1000) {
        sinoscope->time -= 2 * M_PI * 1000;
    }

    return 0;

fail_exit:
    return -1;
}

static int compare_methods(sinoscope_t* serial, sinoscope_t* openmp, sinoscope_t* opencl) {
    int status;

    if (serial->buffer_size != openmp->buffer_size || serial->buffer_size != opencl->buffer_size) {
        LOG_ERROR("buffer sizes mismatch");
        goto fail_exit;
    }

    unsigned int buffer_size = serial->buffer_size;

    status = sinoscope_corners(serial);
    status += sinoscope_corners(openmp);
    status += sinoscope_corners(opencl);
    if (status != 0) {
        LOG_ERROR("failed to forward sinoscope");
        goto fail_exit;
    }

    status = serial->handler(serial);
    status += openmp->handler(openmp);
    status += opencl->handler(opencl);
    if (status != 0) {
        LOG_ERROR("failed to call sinoscope handler");
        goto fail_exit;
    }

    for (int i = 0; i < buffer_size; i++) {
        int serial_value = serial->buffer[i];
        int openmp_value = openmp->buffer[i];
        int opencl_value = opencl->buffer[i];

        if (abs(openmp_value - serial_value) > 0) {
            printf("openmp [%d] differs from serial [%d] at %d\n", openmp_value, serial_value, i);
        }

        if (abs(opencl_value - serial_value) > 10) {
            printf("opencl [%d] differs from serial [%d] at %d\n", opencl_value, serial_value, i);
        }
    }

    return 0;

fail_exit:
    return -1;
}

int sinoscope_check(unsigned int width, unsigned int height, unsigned int taylor, float max,
                    sinoscope_opencl_t* opencl) {
    sinoscope_t* sinoscope_serial = NULL;
    sinoscope_t* sinoscope_openmp = NULL;
    sinoscope_t* sinoscope_opencl = NULL;

    sinoscope_serial = sinoscope_create("serial", sinoscope_image_serial, width, height, max);
    if (sinoscope_serial == NULL) {
        LOG_ERROR("failed to create sinoscope (serial)");
        goto fail_exit;
    }
    sinoscope_serial->taylor = taylor;

    sinoscope_openmp = sinoscope_create("openmp", sinoscope_image_openmp, width, height, max);
    if (sinoscope_openmp == NULL) {
        LOG_ERROR("failed to create sinoscope (openmp)");
        goto fail_exit;
    }
    sinoscope_openmp->taylor = taylor;

    sinoscope_opencl = sinoscope_create("opencl", sinoscope_image_opencl, width, height, max);
    if (sinoscope_opencl == NULL) {
        LOG_ERROR("failed to create sinoscope (opencl)");
        goto fail_exit;
    }
    sinoscope_opencl->taylor = taylor;
    sinoscope_opencl->opencl = opencl;

    for (int i = 0; i < 10; i++) {
        float time             = (((float)rand()) / ((float)RAND_MAX)) * (2 * M_PI * 1000);
        sinoscope_serial->time = time;
        sinoscope_openmp->time = time;
        sinoscope_opencl->time = time;

        if (compare_methods(sinoscope_serial, sinoscope_openmp, sinoscope_opencl) < 0) {
            LOG_ERROR("error when comparing results");
            goto fail_exit;
        }
    }

    sinoscope_destroy(sinoscope_serial);
    sinoscope_destroy(sinoscope_openmp);
    sinoscope_destroy(sinoscope_opencl);

    return 0;

fail_exit:
    if (sinoscope_serial != NULL) {
        sinoscope_destroy(sinoscope_serial);
    }

    if (sinoscope_openmp != NULL) {
        sinoscope_destroy(sinoscope_openmp);
    }

    if (sinoscope_opencl != NULL) {
        sinoscope_destroy(sinoscope_opencl);
    }

    return -1;
}

static uint64_t timespec_diff_us(timespec_t* t1, timespec_t* t2) {
    uint64_t t1_us = (t1->tv_sec * 1e6) + (t1->tv_nsec / 1e3);
    uint64_t t2_us = (t2->tv_sec * 1e6) + (t2->tv_nsec / 1e3);

    return (t1_us > t2_us) ? (t1_us - t2_us) : (t2_us - t1_us);
}

static uint64_t timeval_diff_us(timeval_t* t1, timeval_t* t2) {
    uint64_t t1_us = (t1->tv_sec * 1e6) + t1->tv_usec;
    uint64_t t2_us = (t2->tv_sec * 1e6) + t2->tv_usec;

    return (t1_us > t2_us) ? (t1_us - t2_us) : (t2_us - t1_us);
}

static int benchmark(sinoscope_t* sinoscope, unsigned int iterations) {
    timespec_t start_time;
    if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0) {
        LOG_ERROR_ERRNO("clock_gettime");
        goto fail_exit;
    }

    rusage_t start_usage;
    if (getrusage(RUSAGE_SELF, &start_usage) < 0) {
        LOG_ERROR_ERRNO("getrusage failed");
        goto fail_exit;
    }

    for (unsigned int i = 0; i < iterations; i++) {
        if (sinoscope_corners(sinoscope) < 0) {
            LOG_ERROR("failed to forward sinoscope");
            goto fail_exit;
        }

        if (sinoscope->handler(sinoscope) < 0) {
            LOG_ERROR("failed to call sinoscope handler `%s`", sinoscope->name);
            goto fail_exit;
        }
    }

    timespec_t end_time;
    if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0) {
        LOG_ERROR_ERRNO("clock_gettime");
        goto fail_exit;
    }

    rusage_t end_usage;
    if (getrusage(RUSAGE_SELF, &end_usage) < 0) {
        LOG_ERROR_ERRNO("getrusage failed");
        goto fail_exit;
    }

    uint64_t utime   = timeval_diff_us(&start_usage.ru_utime, &end_usage.ru_utime);
    uint64_t stime   = timeval_diff_us(&start_usage.ru_stime, &end_usage.ru_stime);
    uint64_t elapsed = timespec_diff_us(&start_time, &end_time);

    printf("%s\t%5d    %5u    %8u  %10lu   %10lu    %10lu\n", sinoscope->name, sinoscope->width, sinoscope->height,
           iterations, utime, stime, elapsed);

    return 0;

fail_exit:
    return -1;
}

int sinoscope_benchmark(unsigned int width, unsigned int height, unsigned int taylor, float max,
                        sinoscope_opencl_t* opencl, unsigned int iterations) {
    sinoscope_t* sinoscope_serial = NULL;
    sinoscope_t* sinoscope_openmp = NULL;
    sinoscope_t* sinoscope_opencl = NULL;

    sinoscope_serial = sinoscope_create("serial", sinoscope_image_serial, width, height, max);
    if (sinoscope_serial == NULL) {
        LOG_ERROR("failed to create sinoscope (serial)");
        goto fail_exit;
    }
    sinoscope_serial->taylor = taylor;

    sinoscope_openmp = sinoscope_create("openmp", sinoscope_image_openmp, width, height, max);
    if (sinoscope_openmp == NULL) {
        LOG_ERROR("failed to create sinoscope (openmp)");
        goto fail_exit;
    }
    sinoscope_openmp->taylor = taylor;

    sinoscope_opencl = sinoscope_create("opencl", sinoscope_image_opencl, width, height, max);
    if (sinoscope_opencl == NULL) {
        LOG_ERROR("failed to create sinoscope (opencl)");
        goto fail_exit;
    }
    sinoscope_opencl->taylor = taylor;
    sinoscope_opencl->opencl = opencl;

    printf("=========================================================================\n");
    printf("=========================== benchmark results ===========================\n");
    printf("=========================================================================\n");
    printf("test    width   height  iterations   user (us)  system (us)  elapsed (us)\n");

    if (benchmark(sinoscope_serial, iterations) < 0) {
        LOG_ERROR("failed to benchmark (serial)");
        goto fail_exit;
    }

    if (benchmark(sinoscope_openmp, iterations) < 0) {
        LOG_ERROR("failed to benchmark (openmp)");
        goto fail_exit;
    }

    if (benchmark(sinoscope_opencl, iterations) < 0) {
        LOG_ERROR("failed to benchmark (opencl)");
        goto fail_exit;
    }

    printf("=========================================================================\n");

    sinoscope_destroy(sinoscope_serial);
    sinoscope_destroy(sinoscope_openmp);
    sinoscope_destroy(sinoscope_opencl);

    return 0;

fail_exit:
    if (sinoscope_serial != NULL) {
        sinoscope_destroy(sinoscope_serial);
    }

    if (sinoscope_openmp != NULL) {
        sinoscope_destroy(sinoscope_openmp);
    }

    if (sinoscope_opencl != NULL) {
        sinoscope_destroy(sinoscope_opencl);
    }

    return -1;
}

int sinoscope_save_image(sinoscope_t* sinoscope, char* filename) {
    if (sinoscope_corners(sinoscope) < 0) {
        LOG_ERROR("failed to forward sinoscope");
        goto fail_exit;
    }

    if (sinoscope->handler(sinoscope) < 0) {
        LOG_ERROR("failed to call sinoscope handler `%s`", sinoscope->name);
        goto fail_exit;
    }

    image_t* image = image_create(sinoscope->width, sinoscope->height);
    if (image == NULL) {
        LOG_ERROR("failed to create image");
        goto fail_exit;
    }

    for (int j = 0; j < sinoscope->height; j++) {
        for (int i = 0; i < sinoscope->width; i++) {
            pixel_t* pixel = image_get_pixel(image, i, j);
            if (pixel == NULL) {
                LOG_ERROR("failed to get pixel");
                goto fail_free_image;
            }

            unsigned int index = (i * 3) + (j * 3) * sinoscope->width;
            pixel->bytes[0] = sinoscope->buffer[index + 0];
            pixel->bytes[1] = sinoscope->buffer[index + 1];
            pixel->bytes[2] = sinoscope->buffer[index + 2];
        }
    }

    if (image_save_png(image, filename) < 0) {
        LOG_ERROR("failed to save image");
        goto fail_free_image;
    }

    image_destroy(image);

    return 0;

fail_free_image:
    image_destroy(image);
fail_exit:
    return -1;
}
